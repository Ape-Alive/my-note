<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>单向链表</title>
</head>
<body>
  <script>
    function LinkedList(){
      //属性
      this.head=null
      this.length=0
      //方法
      function Node(data){
        this.data=data
        this.next=null
      }
      //追加方法
      LinkedList.prototype.append=function(data){
        var newNode=new Node(data)
        //判断是否为为第一个节点
        if(this.length===0){
          this.head=newNode
        }else{
          var  current=this.head
          while(current.next){
            current=current.next
          }
          current.next=newNode
        }
        this.length+=1
      }
      //实现toString方法
      LinkedList.prototype.toString=function(){
        //定义一个变量
        var current=this.head
        var listString=''
        //循环获取一个个的节点
        while(current){
          listString+=current.data+' '
          current=current.next

        }
        return listString
      }
      //insert 方法
      LinkedList.prototype.insert=function(position,data){
      //越界判断
      if(position<0||position>this.length) return false
      //根据data 创建节点
      var newNode=new Node(data)
      //插入到position=0 的节点
      if(position===0){
        newNode.next=this.head
        this.head=newNode
        //插入不是第一个
      }else{
        var index=0
        var current=this.head
        var previous=null
        while(index++<position){
          previous=current
          current=current.next

        }
        newNode.next=current
        previous.next=newNode
      }
      this.length+=1
      return true
      }
      //get，给位置获取值
      LinkedList.prototype.get=function(position){
        if(position<0||position>=this.length)return null
        var current=this.head
        var index=0
        while(index++<position){
          current=current.next
        }
        return current.data
      }
     //indexOf方法
     LinkedList.prototype.indexOf=function(data){
       var current =this.head
       var index=0
       //开始查找
       while(current){
           if(current.data===data){
             return index
           }
           current=current.next
           index+=1
       }
       return -1
     }
     //upData方法
      LinkedList.prototype.upData=function(newData,position){
        //边界判断
        if(position<0||position>this.length) return false
        var current=this.head
        var index=0
        while(index++<position){
          current=current.next
        }
        current.data=newData
        return true
      }
      //removeAt方法
     LinkedList.prototype.removeAt=function(position){
       if(position<0||position>=this.length) return false
       if(position==0){
         this.head=this.head.next
       }else{
         var index=0
         var current=this.head
         var previous=null
         while(index++<position){
           previous=current
           current=current.next
         }
         previous.next=current.next
         this.length-=1
         return true

       }
     }
     //remove方法
     LinkedList.prototype.remove=function(data){
       let position=this.indexOf(data)
       this.removeAt(position)
     }
     LinkedList.prototype.isEmpty=function(){
       return this.length==0
     }
     LinkedList.prototype.size=function(){
       return this.length
     }
     }
  </script>
</body>
</html>